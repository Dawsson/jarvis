import { exec } from 'child_process';
import { promisify } from 'util';
import type { JarvisClaudeSession } from './types';

const execAsync = promisify(exec);

interface PROptions {
  title: string;
  body: string;
  baseBranch?: string;
  draft?: boolean;
}

/**
 * Check if gh CLI is installed and authenticated
 */
export async function checkGhCLI(repoPath: string): Promise<boolean> {
  try {
    await execAsync(`cd "${repoPath}" && gh auth status`, { timeout: 5000 });
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Get the default branch for a repository
 */
export async function getDefaultBranch(repoPath: string): Promise<string> {
  try {
    const { stdout } = await execAsync(`cd "${repoPath}" && git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@'`);
    return stdout.trim() || 'main';
  } catch (error) {
    return 'main';
  }
}

/**
 * Check if there are uncommitted changes
 */
export async function hasUncommittedChanges(repoPath: string): Promise<boolean> {
  try {
    const { stdout } = await execAsync(`cd "${repoPath}" && git status --porcelain`);
    return stdout.trim().length > 0;
  } catch (error) {
    return false;
  }
}

/**
 * Commit all changes with a message
 */
export async function commitChanges(repoPath: string, message: string): Promise<void> {
  try {
    await execAsync(`cd "${repoPath}" && git add -A`);
    await execAsync(`cd "${repoPath}" && git commit -m "${message.replace(/"/g, '\\"')}"`);
    console.log(`‚úÖ Committed changes in ${repoPath}`);
  } catch (error: any) {
    throw new Error(`Failed to commit changes: ${error.message}`);
  }
}

/**
 * Push current branch to remote
 */
export async function pushBranch(repoPath: string, branchName?: string): Promise<void> {
  try {
    if (branchName) {
      await execAsync(`cd "${repoPath}" && git push -u origin ${branchName}`);
    } else {
      await execAsync(`cd "${repoPath}" && git push -u origin HEAD`);
    }
    console.log(`‚úÖ Pushed branch to remote`);
  } catch (error: any) {
    throw new Error(`Failed to push branch: ${error.message}`);
  }
}

/**
 * Get current branch name
 */
export async function getCurrentBranch(repoPath: string): Promise<string> {
  try {
    const { stdout } = await execAsync(`cd "${repoPath}" && git branch --show-current`);
    return stdout.trim();
  } catch (error) {
    throw new Error('Failed to get current branch');
  }
}

/**
 * Create a PR using gh CLI
 */
export async function createPR(repoPath: string, options: PROptions): Promise<string> {
  try {
    const baseBranch = options.baseBranch || await getDefaultBranch(repoPath);
    const draftFlag = options.draft ? '--draft' : '';

    const command = `cd "${repoPath}" && gh pr create --base ${baseBranch} --title "${options.title.replace(/"/g, '\\"')}" --body "${options.body.replace(/"/g, '\\"')}" ${draftFlag}`;

    const { stdout } = await execAsync(command);
    const prUrl = stdout.trim();

    console.log(`‚úÖ Created PR: ${prUrl}`);
    return prUrl;
  } catch (error: any) {
    throw new Error(`Failed to create PR: ${error.message}`);
  }
}

/**
 * Generate PR title from session task
 */
export function generatePRTitle(session: JarvisClaudeSession): string {
  // Clean up the task to make a good PR title
  let title = session.task;

  // Remove common prefixes
  title = title.replace(/^(please |can you |could you )/i, '');

  // Capitalize first letter
  title = title.charAt(0).toUpperCase() + title.slice(1);

  // Limit length
  if (title.length > 72) {
    title = title.slice(0, 69) + '...';
  }

  return title;
}

/**
 * Generate PR body from session
 */
export function generatePRBody(session: JarvisClaudeSession): string {
  const lines: string[] = [];

  lines.push('## Summary');
  lines.push('');
  lines.push(session.task);
  lines.push('');

  if (session.files_created.length > 0 || session.files_modified.length > 0) {
    lines.push('## Changes');
    lines.push('');

    if (session.files_created.length > 0) {
      lines.push('**Files created:**');
      session.files_created.forEach(file => lines.push(`- ${file}`));
      lines.push('');
    }

    if (session.files_modified.length > 0) {
      lines.push('**Files modified:**');
      session.files_modified.forEach(file => lines.push(`- ${file}`));
      lines.push('');
    }
  }

  lines.push('---');
  lines.push('');
  lines.push('ü§ñ Generated by [Jarvis](https://github.com/yourusername/jarvis)');
  lines.push(`Session ID: ${session.session_id}`);

  return lines.join('\n');
}

/**
 * Auto-create PR for completed session
 */
export async function autoCreatePR(session: JarvisClaudeSession): Promise<string | null> {
  try {
    const repoPath = session.worktree_path || session.repository_path || session.cwd;

    // Check if gh CLI is available
    const hasGh = await checkGhCLI(repoPath);
    if (!hasGh) {
      console.log('‚ö†Ô∏è  gh CLI not available, skipping PR creation');
      return null;
    }

    // Get current branch
    const currentBranch = await getCurrentBranch(repoPath);
    const defaultBranch = await getDefaultBranch(repoPath);

    // Don't create PR if on default branch
    if (currentBranch === defaultBranch) {
      console.log(`‚ö†Ô∏è  On default branch (${defaultBranch}), skipping PR creation`);
      return null;
    }

    // Check for uncommitted changes
    const hasChanges = await hasUncommittedChanges(repoPath);
    if (hasChanges) {
      // Commit changes
      const commitMessage = `${session.task}\n\nü§ñ Completed by Jarvis\nSession: ${session.session_id}`;
      await commitChanges(repoPath, commitMessage);
    }

    // Push branch
    await pushBranch(repoPath, currentBranch);

    // Create PR
    const title = generatePRTitle(session);
    const body = generatePRBody(session);

    const prUrl = await createPR(repoPath, {
      title,
      body,
      baseBranch: defaultBranch,
      draft: false,
    });

    return prUrl;
  } catch (error: any) {
    console.error(`Failed to create PR: ${error.message}`);
    return null;
  }
}
